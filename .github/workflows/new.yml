name: Release Notification

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'

jobs:
  check-upstream-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Install axios
        run: npm install axios

      - name: Check for New Release
        id: check-release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const axios = require('axios');
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const upstreamRepo = 'roothide/bootstrap';
            const apiURL = `https://api.github.com/repos/${upstreamRepo}/releases/latest`;
            const releaseFilePath = path.join(process.env.GITHUB_WORKSPACE, 'latest_release.txt');

            async function getLatestRelease() {
              try {
                const response = await axios.get(apiURL);
                return response.data.tag_name;
              } catch (error) {
                console.error(`Failed to fetch the latest release: ${error}`);
                return null;
              }
            }

            function getChangedFiles(previousTag, currentTag) {
              const command = `git diff --name-status ${previousTag}..${currentTag}`;
              const output = execSync(command).toString();
              const changes = output.trim().split('\n').map(line => {
                const [status, ...paths] = line.split('\t');
                return { status, path: paths.join('\t') }; // Joining all parts except the first (status)
              });
              return changes;
            }

            function generateChangeLog(changes) {
              const tableHeader = `| File | Change Type |\n| --- | --- |`;
              const tableRows = changes.map(change => {
                let changeType;
                switch (change.status) {
                  case 'A': changeType = 'Added'; break;
                  case 'M': changeType = 'Modified'; break;
                  case 'D': changeType = 'Deleted'; break;
                  case 'R': changeType = 'Renamed'; break;
                  default: changeType = 'Unknown'; break;
                }
                return `| ${change.path} | ${changeType} |`;
              }).join('\n');
              return `${tableHeader}\n${tableRows}`;
            }

            async function run() {
              const latestRelease = await getLatestRelease();
              if (!latestRelease) return;

              let previousRelease = '';
              if (fs.existsSync(releaseFilePath)) {
                previousRelease = fs.readFileSync(releaseFilePath, 'utf8');
              }

              if (latestRelease !== previousRelease) {
                fs.writeFileSync(releaseFilePath, latestRelease, 'utf8');
                console.log(`Found a new release: ${latestRelease}`);

                if (previousRelease) {
                  const changes = getChangedFiles(previousRelease, latestRelease);
                  const changeLog = generateChangeLog(changes);
                  console.log('Change Log:\n', changeLog);
                  core.setOutput('change-log', changeLog);
                }

                core.setOutput('new-release', latestRelease);
              } else {
                console.log(`No new releases found. The latest release is still: ${previousRelease}`);
              }
            }

            run();

      - name: Do something with the changelog
        if: steps.check-release.outputs.change-log
        run: |
          echo "Changelog:"
          echo "${{ steps.check-release.outputs.change-log }}"
